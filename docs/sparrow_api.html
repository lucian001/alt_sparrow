<DOCTYPE html>
<HTML>
<HEAD>
	<TITLE>Sparrow API</TITLE>
	<LINK REL="stylesheet" Type="text/css" HREF="sparrow.css" />
</HEAD>
<BODY BGCOLOR="#cdb79e">
        <CENTER><IMG SRC="Sparrow.png" /></CENTER><BR><BR>
<DIV CLASS="container">
        <CENTER><P><B>The Sparrow API is a set of C functions that extend the Altera HW Libs API in order to allow users to quickly and easily run multiple operating systems independently from each other</B></P></CENTER>
<H1>HW Libs</H1>
<P>The Sparrow API both uses and extends the HW Libs API. The documentation for HW Libs is provided with the latest release of SocEDS. Sparrow was developed to be consistant in both function and variable names with HW Libs. Some of the functions in Sparrow may eventually be absorbed into HW Libs</P>
<H1>The Sparrow API</H1>
	<H2>Standard Functions</H2>
	<P>Sparrow provides definitions for a set of c standard functions that programers has become accustomed to. They consist of the following:</P>
		<H4>__aebi_uidivmod<BR> __aebi_uidiv<BR> __aebi_uldivmod<BR> 
			__aebi_uldiv<BR> __aebi_idiv<BR> __aebi_idivmod</H4>
		<P>The arm processor does not have a built in oppre for division. In order for division to work properly, the ARM compiler turns divisions into a call to one of these functions. In order for baremetal applications to use division and link correctly, the divide.c function must be compiled and linked in.</P>
		<H4>printf<BR></H4>
		<P>printf will print to uART0
		<H4>fprintf</H4>
		<P>fprintf will print to a different output based on the FILE passed in. Valid values include:
		<UL>
		<LI><B>term0</B> uART0
		<LI><B>term1</B> uART1
		<LI><B>LOG0</B> Memory based logging. To use this you will need to first call init_log_buffer()
		<LI><B>LOG1</B> 
		<LI><B>LOG2</B> 
		<LI><B>LOG3</B> 
		</UL>
		<H4>memcpy<BR></H4>
	<H2>Log Buffer Functions</H2>
		<P>The log_buffer api allows users to print to a buffer which can be opened and viewed from Linux. After calling init_log_buffer the developer can use fprintf to print to the log buffer. To read the log in Linux use the program dumpLog
		<H4>uint32 init_log_buffer(FILE *f_logid, void *location, uint32 size)</H4>
		<P>This function tells sparrow where the memory is that should be associated with the file pointer. Valid values for f_logid are the same as the FILE values for fprintf


	<H2>Cache Functions</H2>
	<P>HW Libs provide most of the functionality that users need for initializing and configuring the L1 and L2 caches. Sparrow extends these by providing users the ability to configure the cache to be partitioned, allowing each of the operating systems to access only one part at a time. Sparrow also allows instructions to be preloaded into the instruction cache</P>
		<H4>void alt_cache_l2_set_locks(uint32 cpus_di, uint32 ways)</H4> 
		<P>This function allows the user to lock pieces of the cache such that new entries will not be loaded into it from a particular source. The L2 cache is divided into 8 x 64kb cache sections called "WAYS". To assign a Way to a given processor use the hwlibs to clear the entrys in that Way, then lock all other processors from that Way. Failing to clean the Way could cause entrys that are already in the way to continue to be cached until evicted.
		<UL>
		<LI>cpus_di - This identifies with processors and types you wish to lock out of these specified ways. Valid values include the following: CPU_NONE, CPU0_DATA, CPU0_INSTRUCTIONS, CPU0 (both data and instructions), CPU1_DATA, CPU1_INSTRUCTIONS, or CPU1(both data and instructions). Multiple values may be passed by ORing them together</LI>
		<LI>ways - This identified which ways you want to lock. This may include any of the following values, and multiple values may be specified by ORing them together. WAY0, WAY1, WAY2, WAY3, WAY4, WAY5, WAY6, WAY7, WAY0_3 (ways 0-3, WAY4_7 (ways 4-7), WAY0_7 (all ways)</LI>
		</UL>
		<P>
		Example:<BR>
		The following pre assigns WAY0 to cpu1 instructions, WAY1 to cpu1 data and all other ways to cpu0:
		<pre>alt_cache_l2_set_locks(CPU0|CPU1_DATA, WAY0);
		alt_cache_l2_set_locks(CPU0|CPU1_INSTRUCTION, WAY1);
		alt_cache_l2_set_locks(CPU1, WAY2|WAY3|WAY4_7);
		</pre>
		<H4>void alt_cache_l2_load2ways(void *where, uint32 size, uint32 ways)</H4>
<P>This function provides the user with a way to load code and/or data into the cache. After returning from this function all ways will be locked. You will need to use alt_cache_l2_set_locks() to unlock them
		<H4>void  alt_cache_l2_clean_cache_by_way( uint32 ways)</H4>
<P>For the specified ways, this function will clean all cache entries - cleaning an entry will copy it to L3 (physical memory) if it was dirty
		<H4>void alt_cache_l2_invalidate_cache_by_way( uint32 ways)</H4>
<P>For the specified ways, this function will invalidate all entries - invalidating an entry to simply remove the entry. Any dirty values will be lost.
		<H4>void alt_cache_l2_clean_invalidate_cache_by_way( uint32 ways)</H4>
<P>This function will both clean and invalidate all entries in the given ways


	<H2>Generic Interrupt Controller</H2>
		<P>The GIC is automatically initialized when sparrow is started. Per-CPU initialization is performed by each CPU as it is taken out of reset.


	<H2>Memory Pools</H2>
		<P>Memory Pools allow the user to set aside a portion of memory for allocation. This library can be used by itself for memory allocation, or in collaboration with the alt_mmu_va_space_create() function in HWlibs in order to provide that function with the memory needed for allocating page tables. This libarary is used in the code generated for the various Map functions. Thus, even if you don't directly use this library, it is required by Map functions.<BR>
		Note that these pools do not have a deallocation function and thus are not suitable as standard heap allocation.
	<H4>MemPool</H4>
		<P>The MemPool type is a structure which will contain information required by Mempool functions. It is a required parameter for all calls, and is 64 bits in size
	<H4>void MemPoolInit(MemPool *pool, uint32 memloc, uint32 size)</H4>
		<P>This function assigns the memory at memloc[+size] to the memory pool pointed to at "pool". The pool paramter is a pointer to a structure and must point to valid memory of size(MemPool).
	<H4>void *MemPoolAlloc(const size_t size, void * pool)</H4>
		<P>This funtion allocates "size" bytes of memory from the memory pool pointed to at "pool". Note that the pool paramter is a void * in order to compile cleanly with the alt_mmu_va_space_create() function, but it should always point to a MemPool structure that has been previously initialized using the MemPoolInit() funtion above


	<H2>Neon</H2>
		<P>The ARM CortexA9 used by Altera contains a coprocessor called NEON which can be used to accelerate a variety of parallel tasks. If your code contains iterative function and the compiler is set to optimize these functions, it may generate neon instructions. However, the neon core must be enabled before the neon op-codes are used or else a undefined instruction interrupt will occur
	<H4>void __enable_neon(void)</H4>
		<P>This function simply enables the neon coprocessor


	<H2>Reset</H2>
		<P>This library contains the code required for starting the cpu cores. When the system is reset, only cpu core 0 is enabled and all others are in the reset state. Although taking eah of the other cores out of reset in simple, there is some complexity in insuring that they are initialized correctly before being used
	<H4>typedef void reset_function(void);</H4>
		<P>The reset_function type defines the parameters for the start function that will be called by the new core after it has been taken out of reset and initialized
	<H4>void wakeup_CPU(uint32 cpuNum, reset_function *call_function)</H4>
		<P>This function will take the core <cpuNum> out of reset and initialize it. For a dual-core system the cpuNum must be 1. The call_function is the function that will be called after it is initialized.<BR>
		When a core is taken out of reset it begins to execute instructions at physical address 0 in Trustzone Secure mode. If the memory at address 0 is not accessable to Trustzone Secure transactions then the processor will not be able to start correctly. Thus, it is important to take each of the cores out of reset before configuring the memory access in Trustzone. The wakeup_CPU function will copy the startup code to address 0 before taking the other core out of reset, then recover the memory at that location after the other core has begun. This should be invisible to the application.<BR>
	<H4>void wait_for_event(void)</H4>
		<P>This function uses the arm wfe instruction to put the processor to sleep until an event occurs. Events include interrupts (even masked ones), swi instructions from other processors and jtag operations. See ARM documentation for more information on this instruction
	<H4>void wait_for_interrupt(void)</H4>
		<P>This function uses the arm wfi instruction to put the processor to sleep until an interrupt occurs. See ARM documentation for more information on this instruction


	<H2>SCU</H2>
		<P>The Synchronization Control Unit (SCU) is a component of the ARM CortexA9 which is designed to synchronize the L1 caches of the different cores of the CPU.
	<H4>void enable_scu(void)</H4>
		<P>This function enables the SCU unit. The unit will synchronize the data caches of each core that is subscibed to the SCU. Initially, no cores are subscibed.
	<H4>void enable_smp(void)</H4>
		<P>This function sets the SMP bit on the core calling this function, causing the core to be subscribed to SMP synchronization. It will not effect the same bit for the other processors. All processors that are subscribed to SMP will share branch prediction values, instruction caches, and ttb lookup caches. 


	<H2>Trustzone</H2>
		<P>Trustzone is responsible for insuring that the OSes/cores/contexts do not improperly access each other's resources. This is done via an extra bit on memory accesses that indicate that the transaction is either Secure or Nonsecure. Each device has a policy which will determine whether that device can receive Secure, Nonsecure or both kinds of accesses. For DMA devices there is also a policy to determine whether DMA accesses are Secure or Nonsecure. Most devices require Secure access by default and must be reconfigured to accept nonsecure memory transactions.<BR>
	<H3>Configuring the SDRam Controller</H3>
		<P>The SDRam controller has a default rule and up to 20 overriding rules. When a memory transaction arrives at the SDRam controller, if a rule matches the port, security state and memory range of the transaction then it will be accepted or rejected depending on that rule. However, if no rule matches the transaction then the default rule will apply<BR>
	<H4>uint32  alt_sdr_ctl_set_tz_default(uint32 defaultRule)</H4>
	<UL><LI>
		<B>defaultRule</B> Should be one or more of the following ORed together:
		<UL>
		<LI>ALT_SDR_CTL_PROTPORT_DENY_NONE</LI>
		<LI>ALT_SDR_CTL_PROTPORT_DENY_FPGA</LI>
		<LI>ALT_SDR_CTL_PROTPORT_DENY_CPU_READ</LI>
		<LI>ALT_SDR_CTL_PROTPORT_DENY_CPU_WRITE</LI>
		<LI>ALT_SDR_CTL_PROTPORT_DENY_L3_READ</LI>
		<LI>ALT_SDR_CTL_PROTPORT_DENY_L3_WRITE</LI>
		<LI>ALT_SDR_CTL_PROTPORT_DENY_CPU</LI>
		<LI>ALT_SDR_CTL_PROTPORT_DENY_L3</LI>
		</UL>
	</LI></UL>
	<H4>uint32  alt_sdr_ctl_set_tz_rule(uint32 RuleNum, uint32 LowAddr, uint32 HighAddr, uint32 RuleMin, uint32 RuleMax, uint32 SecurityType, uint32 Ports, uint32 AccessPermission)</H4>
	<UL>
		<LI><B>RuleNum</B> Up to 20 rules may be assigned. You may explicity chose which rule to use or you may pass ALT_SDR_CTL_RULE_NEW and the next unused rule will be used.</LI>
		<LI><B>LowAddr</B> This is the physical address of the lower bound of the memory</LI>
		<LI><B>HighAddr</B> This is the physical address of the higher bound of the memory</LI>
		<LI><B>RuleMin</B> Each device communicates using a set of IDs. You may selectively allow this Rule to only apply to certain devices by setting this and RuleMax for those devices. The values for these IDs can be found in sparrow in src/sparrow/trustzone.h. To select all devices, use ALT_SDR_CTL_RULEID_MIN.</LI>
		<LI><B>RuleMax</B> To select all devices use ALT_SDR_CTL_RULEID_MAX</LI>
		<LI><B>SecurityType</B> Should be one of the following:<UL>
			<LI>ALT_SDR_CTL_DATA_ACCESS_SECURE - This rule applies only to Trustzone Secure accesses</LI>
			<LI>ALT_SDR_CTL_DATA_ACCESS_NONSECURE - This rule applies only to Trustzone Nonsecure accesses</LI>
			<LI>ALT_SDR_CTL_DATA_ACCESS_BOTH - This rule applies to both Secure and Nonsecure accesses</LI>
			</UL></LI>
		<LI><B>Ports</B> Should be one of the following:<UL>
			<LI>ALT_SDR_CTL_DATA_RULE_PORT_FPGA - This rule applies to transactions from the FPGA</LI>
			<LI>ALT_SDR_CTL_DATA_RULE_PORT_L3 - This rule applies to transactions from peripherals</LI>
			<LI>ALT_SDR_CTL_DATA_RULE_ACCESS_CPUS - This rule applies to transactions from the CPU</LI>
			<LI>ALT_SDR_CTL_DATA_RULE_ALL_PORTS - This applies to transactions regardless of origin</LI>
			</UL></LI>
		<LI><B>AccessPermission</B> Should be either ALT_SDR_CTL_DATA_DENY_ACCESS or ALT_SDR_CTL_DATA_ALLOW_ACCESS </LI>
	</UL>
	<H4>void alt_sdr_ctl_delete_rule(uint32 RuleNum)</H4>
	<P>This function will remove a rule that was created using alt_sdr_ctl_set_tz_rule. The RuleNum should be value returned by the alt_sdr_ctl_set_tz_rule call


	<H3>Configuring SystemPheripherals</H3>
	<H4>void alt_l3_secgrp_set_peripheral_access(uint64 NonSecure, uint64 SecureOnly)</H4>
		<P>This function will set the specified devices to either allow or deny access to nonsecure memory transactions. Each parameter is a combination of flags that indicate which devices. The first value indicates which devices should allow nonsecure accesses and the second indicates which devices should be deny such accesses. All other devices will not be changed. Devices cannot be set to deny Secure accesses. The possible values are:
	<UL>
	<LI>ALT_L3_SEC_PERIPHERAL_DMA          </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_USB0        </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_USB1        </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_CAN0        </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_CAN1        </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_SDMMC       </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_NAND        </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_QSPI        </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_SPI0_SLAVE  </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_SPI1_SLAVE  </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_SPI0_MASTER </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_SPI1_MASTER </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_I2C0        </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_I2C1        </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_I2C2        </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_I2C3        </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_EMAC0       </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_EMAC1       </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_UART0       </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_UART1       </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_GPIO0       </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_GPIO1       </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_GPIO2       </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_SPTIMER0    </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_SPTIMER1    </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_OSCTIMER0   </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_OSCTIMER1   </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_WATCHDOG0   </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_WATCHDOG1   </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_CLKMGR      </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_OCR         </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_ACP         </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_ROM         </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_SDRAMCTRL   </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_DAP         </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_RESET       </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_SYSMGR      </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_SCANMGR     </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_STMSLAVE    </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_FPGA        </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_FPGAMNGR    </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_GLOBALTIMER </LI>
	<LI> ALT_L3_SEC_PERIPHERAL_PRIVATETIMER</LI>
	</UL>


	<H3>Starting Operating Systems</H3>
	<H4>void start_nonsecure(uint32 where, uint32 StackEnd)</H4>
		<P>This function transitions the CPU to Nonsecure mode and starts the operating system at address "where". The registers are set to simulate a call from uboot with any paramters that were passed by uboot to sparrow when it began executing. Any Secure Monitor Call (SMC) requests from the nonsecure os will by processed by Sparrow, but this requires a Stack. The End address of this stack is specified by "StackEnd"
	<H4>void start_secure(uint32 where)</H4>
		<P>This function begins execution of the operating system at address "where". This is similar to (*where)()


	<H2>Uart</H2>
		<P>HWLibs provides a variety of functions for printing. However, these functions require connection paramters which they will use to program the uART. If the user wishes to continue using the parameters already assigned by uboot then this may not be an issue.
	<H4>int getch(void)</H4>
		<P>This function will return the character code of the value passed to the system via the uart. This can be used to read in input from the user. It is a blocking function and thus will not return until a character is passed
	<H4>extern void uart_putchar(int port, char toprint)</H4>
		<P>This function will send a value to the uart. It may block if the UART is currently in use
	<H4>extern int init_uart1()</H4>
		<P>This function will copy the connection paramters from UART0 to UART1. This may be useful for circumstances when the developer would like to communicate on both uarts simultaneously
</DIV>
